// @generated by protobuf-ts 2.9.6
// @generated from protobuf file "sessions.proto" (package "authentication", syntax proto3)
// tslint:disable
//
//-- ./proto/sessions.proto
//
//
/// # Sessions Service Definition
///
/// This service is used to manage user sessions.
///
/// It allows for the creation, retrieval, revocation, and deletion of sessions.
///
/// It includes definitions for:
/// - `Read` - Get a session by ID
/// - `Index` - Get a list of sessions
/// - `Revoke` - Revoke a session by ID
/// - `RevokeUser` - Revoke all sessions for a user
/// - `RevokeAll` - Revoke all sessions
/// - `Delete` - Delete a session by ID
/// - `DeleteUser` - Delete all sessions for a user
/// - `DeleteAll` - Delete all sessions
//
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { SessionsService } from "./sessions";
import type { SessionsDeleteUserRequest } from "./sessions";
import type { SessionsDeleteResponse } from "./sessions";
import type { SessionsDeleteRequest } from "./sessions";
import type { Empty } from "./common";
import type { SessionsRevokeUserRequest } from "./sessions";
import type { SessionsRevokeResponse } from "./sessions";
import type { SessionsRevokeRequest } from "./sessions";
import type { SessionsIndexResponse } from "./sessions";
import type { SessionsIndexRequest } from "./sessions";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { SessionsResponse } from "./sessions";
import type { SessionsReadRequest } from "./sessions";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Protobuf service definition
 *
 * @generated from protobuf service authentication.SessionsService
 */
export interface ISessionsServiceClient {
    /**
     * Get a session by ID
     *
     * @generated from protobuf rpc: Read(authentication.SessionsReadRequest) returns (authentication.SessionsResponse);
     */
    read(input: SessionsReadRequest, options?: RpcOptions): UnaryCall<SessionsReadRequest, SessionsResponse>;
    /**
     * Get a list of sessions with optional limit and offset for pagination.
     *
     * @generated from protobuf rpc: Index(authentication.SessionsIndexRequest) returns (authentication.SessionsIndexResponse);
     */
    index(input: SessionsIndexRequest, options?: RpcOptions): UnaryCall<SessionsIndexRequest, SessionsIndexResponse>;
    /**
     * Revoke a session by ID
     * This will invalidate the session and remove the refresh token.
     * The session will still exist in the database, but it will be marked as
     * inactive.
     * The session will not be deleted.
     *
     * @generated from protobuf rpc: Revoke(authentication.SessionsRevokeRequest) returns (authentication.SessionsRevokeResponse);
     */
    revoke(input: SessionsRevokeRequest, options?: RpcOptions): UnaryCall<SessionsRevokeRequest, SessionsRevokeResponse>;
    /**
     * Revoke all sessions for a user
     * This will invalidate all sessions for the user and remove all refresh
     * tokens. The sessions will still exist in the database, but they will be
     * marked as inactive. The sessions will not be deleted.
     *
     * @generated from protobuf rpc: RevokeUser(authentication.SessionsRevokeUserRequest) returns (authentication.SessionsRevokeResponse);
     */
    revokeUser(input: SessionsRevokeUserRequest, options?: RpcOptions): UnaryCall<SessionsRevokeUserRequest, SessionsRevokeResponse>;
    /**
     * Revoke all sessions
     * This will invalidate all sessions and remove all refresh tokens.
     * The sessions will still exist in the database, but they will be marked as
     * inactive.
     * The sessions will not be deleted.
     *
     * @generated from protobuf rpc: RevokeAll(authentication.Empty) returns (authentication.SessionsRevokeResponse);
     */
    revokeAll(input: Empty, options?: RpcOptions): UnaryCall<Empty, SessionsRevokeResponse>;
    /**
     * Delete a session by ID
     * This will remove the session from the database.
     * The session will no longer exist in the database.
     *
     * @generated from protobuf rpc: Delete(authentication.SessionsDeleteRequest) returns (authentication.SessionsDeleteResponse);
     */
    delete(input: SessionsDeleteRequest, options?: RpcOptions): UnaryCall<SessionsDeleteRequest, SessionsDeleteResponse>;
    /**
     * Delete all sessions for a user
     * This will remove all sessions for the user from the database.
     * The sessions will no longer exist in the database.
     *
     * @generated from protobuf rpc: DeleteUser(authentication.SessionsDeleteUserRequest) returns (authentication.SessionsDeleteResponse);
     */
    deleteUser(input: SessionsDeleteUserRequest, options?: RpcOptions): UnaryCall<SessionsDeleteUserRequest, SessionsDeleteResponse>;
    /**
     * Delete all sessions
     * This will remove all sessions from the database.
     * The sessions will no longer exist in the database.
     * This is a destructive operation and should be used with caution.
     *
     * @generated from protobuf rpc: DeleteAll(authentication.Empty) returns (authentication.SessionsDeleteResponse);
     */
    deleteAll(input: Empty, options?: RpcOptions): UnaryCall<Empty, SessionsDeleteResponse>;
}
/**
 * Protobuf service definition
 *
 * @generated from protobuf service authentication.SessionsService
 */
export class SessionsServiceClient implements ISessionsServiceClient, ServiceInfo {
    typeName = SessionsService.typeName;
    methods = SessionsService.methods;
    options = SessionsService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Get a session by ID
     *
     * @generated from protobuf rpc: Read(authentication.SessionsReadRequest) returns (authentication.SessionsResponse);
     */
    read(input: SessionsReadRequest, options?: RpcOptions): UnaryCall<SessionsReadRequest, SessionsResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<SessionsReadRequest, SessionsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Get a list of sessions with optional limit and offset for pagination.
     *
     * @generated from protobuf rpc: Index(authentication.SessionsIndexRequest) returns (authentication.SessionsIndexResponse);
     */
    index(input: SessionsIndexRequest, options?: RpcOptions): UnaryCall<SessionsIndexRequest, SessionsIndexResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<SessionsIndexRequest, SessionsIndexResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Revoke a session by ID
     * This will invalidate the session and remove the refresh token.
     * The session will still exist in the database, but it will be marked as
     * inactive.
     * The session will not be deleted.
     *
     * @generated from protobuf rpc: Revoke(authentication.SessionsRevokeRequest) returns (authentication.SessionsRevokeResponse);
     */
    revoke(input: SessionsRevokeRequest, options?: RpcOptions): UnaryCall<SessionsRevokeRequest, SessionsRevokeResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<SessionsRevokeRequest, SessionsRevokeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Revoke all sessions for a user
     * This will invalidate all sessions for the user and remove all refresh
     * tokens. The sessions will still exist in the database, but they will be
     * marked as inactive. The sessions will not be deleted.
     *
     * @generated from protobuf rpc: RevokeUser(authentication.SessionsRevokeUserRequest) returns (authentication.SessionsRevokeResponse);
     */
    revokeUser(input: SessionsRevokeUserRequest, options?: RpcOptions): UnaryCall<SessionsRevokeUserRequest, SessionsRevokeResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<SessionsRevokeUserRequest, SessionsRevokeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Revoke all sessions
     * This will invalidate all sessions and remove all refresh tokens.
     * The sessions will still exist in the database, but they will be marked as
     * inactive.
     * The sessions will not be deleted.
     *
     * @generated from protobuf rpc: RevokeAll(authentication.Empty) returns (authentication.SessionsRevokeResponse);
     */
    revokeAll(input: Empty, options?: RpcOptions): UnaryCall<Empty, SessionsRevokeResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, SessionsRevokeResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Delete a session by ID
     * This will remove the session from the database.
     * The session will no longer exist in the database.
     *
     * @generated from protobuf rpc: Delete(authentication.SessionsDeleteRequest) returns (authentication.SessionsDeleteResponse);
     */
    delete(input: SessionsDeleteRequest, options?: RpcOptions): UnaryCall<SessionsDeleteRequest, SessionsDeleteResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<SessionsDeleteRequest, SessionsDeleteResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Delete all sessions for a user
     * This will remove all sessions for the user from the database.
     * The sessions will no longer exist in the database.
     *
     * @generated from protobuf rpc: DeleteUser(authentication.SessionsDeleteUserRequest) returns (authentication.SessionsDeleteResponse);
     */
    deleteUser(input: SessionsDeleteUserRequest, options?: RpcOptions): UnaryCall<SessionsDeleteUserRequest, SessionsDeleteResponse> {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return stackIntercept<SessionsDeleteUserRequest, SessionsDeleteResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Delete all sessions
     * This will remove all sessions from the database.
     * The sessions will no longer exist in the database.
     * This is a destructive operation and should be used with caution.
     *
     * @generated from protobuf rpc: DeleteAll(authentication.Empty) returns (authentication.SessionsDeleteResponse);
     */
    deleteAll(input: Empty, options?: RpcOptions): UnaryCall<Empty, SessionsDeleteResponse> {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return stackIntercept<Empty, SessionsDeleteResponse>("unary", this._transport, method, opt, input);
    }
}
